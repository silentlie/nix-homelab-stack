# Vault Agent Secrets Distribution — Design Rationale

## Summary

This setup **intentionally prioritizes operational stability and predictability** over fine-grained, per-container filesystem isolation.

All files generated by **Vault Agent** are written to a shared bind-mounted directory with **simple, permissive permissions** so that:

- Vault Agent can always write and rotate secrets
- Consuming containers can always read secrets
- Docker image updates, entrypoint changes, UID/GID differences, or `gosu` / `su-exec` behavior do **not** break the system
- No per-container UID/GID coordination or group management is required

This is a **conscious design choice**, not an oversight.

---

## Threat Model (Explicit)

### In scope

- Single-operator homelab
- All containers are trusted
- No multi-tenant users
- No untrusted workloads
- Accidental misconfiguration and image updates are more likely than active attacks

### Out of scope (accepted risks)

- Host root compromise
  → If the host is compromised, all secrets are considered lost regardless of file permissions
- Malicious containers intentionally mounted with the secrets directory

This design protects against **operational failure**, not against a compromised host.

---

## Design Choice

### Filesystem permissions

- **All Vault Agent–generated files use mode `0644`**
- **All directories use mode `0755`**
- No ACLs
- No `setgid`
- No shared groups
- No reliance on container UID/GID behavior

This guarantees:

- Vault Agent can always overwrite or rotate secrets
- Consumers can always read secrets
- No permission-related runtime failures

---

## Why this approach was chosen

### Problems explicitly avoided

- Coordinating UID/GID across heterogeneous Docker images
- Relying on `group_add` surviving `gosu` / `su-exec`
- Image-specific behavior that may change on updates
- Per-container permission testing and documentation
- Secrets rotation failures due to ownership drift
- Debugging permission issues that appear only after upgrades or restarts

### Lessons learned

- UNIX permissions **cannot** simultaneously guarantee:
  - agent rewrite access
  - consumer read access
  - no shared groups
  - no UID alignment
- Forcing all four leads to fragile systems
- Partial hardening is worse than an explicit, documented simplification

---

## What security is still preserved

- Secrets are **not exposed outside Docker**
- Only containers with the bind mount can read secrets
- No network exposure of secrets
- No runtime `chmod` / `chown`
- Clear separation between agent-only data and consumable outputs

---

## Directory Structure

```
vault/agent/file/
├── public/        # mounted into consuming containers
│   ├── certs/
│   ├── *.env
│   └── *.key
└── agent-only/    # mounted only into vault-agent
    ├── approle/
    ├── token
    └── internal state

```

Only `public/` is mounted into application containers.

---


## Why not 0600 / shared groups / per-container UID fixes?

These approaches were evaluated and rejected because they require:

- Testing each Docker image’s entrypoint behavior
- Verifying group preservation across updates
- Managing per-container UID/GID policies
- Re-documenting assumptions for future maintenance
- High risk of self-inflicted outages

Given the threat model, the operational cost outweighs the benefit.

---

## When to reconsider this design

Revisit this decision if **any** of the following become true:

- Running untrusted or third-party containers
- Multi-user host
- Secrets must be isolated *between* containers
- Regulatory or compliance requirements apply
- Migrating to Kubernetes or another platform with native secret abstractions

---

## One-sentence reminder for future me

> *This system trades intra-container isolation for reliability; permissions are permissive by design to avoid fragile UID/GID coupling.*

---

**This document exists so future changes are intentional, not accidental.**
